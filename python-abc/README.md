# Python OOP – Abstract Classes, Interfaces & Subclassing

## Introduction
In this project I demonstrate my ability to work with advanced **Object-Oriented Programming (OOP)** concepts in Python.  
I designed these exercises to showcase how I approach abstraction, interface design, and the creation of flexible, reusable class hierarchies.  
My goal was to build code that a recruiter or technical lead can quickly see as clean, well-structured, and production-ready.

---

## What I Set Out to Demonstrate

### Abstract Classes
I use Python’s `abc` module to define **abstract base classes**, ensuring that any subclass provides required methods and follows a consistent interface.

### Interfaces & Duck Typing
Rather than relying only on explicit inheritance, I highlight Python’s **duck typing** philosophy—showing how to design code that works as long as an object meets the expected protocol.

### Subclassing Standard Base Classes
I extend core data structures like **lists**, **dictionaries**, and **iterators** to prove I can build specialized containers while preserving built-in behaviors.

### Method Overriding
I override base class methods to illustrate how I adapt or enhance functionality without breaking the original design.

### Multiple Inheritance
I apply **multiple inheritance** carefully to model complex relationships and demonstrate that I understand the method resolution order (MRO) and how to manage it safely.

### Mixins
I incorporate **mixins** to compose reusable behavior across unrelated classes, showing that I can design code for maximum flexibility and minimal duplication.

---

## Why This Matters
These exercises reveal how I think about **software design**—balancing Pythonic flexibility with clear contracts and maintainability.  
For a recruiter or hiring manager, it’s a direct look at how I structure code when building scalable, team-friendly systems.

---
